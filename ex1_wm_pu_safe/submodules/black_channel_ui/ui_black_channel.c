////////////////////////////////////////////////////////////////////////////////
// COPYRIGHT (c) 2021
// EMSISO
// All rights reserved.
////////////////////////////////////////////////////////////////////////////////
/**
* @file     ui_black_channel.c
* @brief    Black channel communication implementation in SAFE/Class B.
* @author   Dusan Slavinec
* @date     29.12.2021
* @version  V1.0.0
*/
////////////////////////////////////////////////////////////////////////////////
/**
* @addtogroup BLACK_CHANNEL
* @{ <!-- BEGIN GROUP -->
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Includes
////////////////////////////////////////////////////////////////////////////////
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include "ui_black_channel.h"
#include "ui_crc_16_arc.h"

////////////////////////////////////////////////////////////////////////////////
// Definitions
////////////////////////////////////////////////////////////////////////////////
/**
 * Communication status.
 */
typedef enum
{
    eUI_BLACKCH_OK               = 0x00, /**< Received valid frame. */
    eUI_BLACKCH_MISMATCH_CRC     = 0x01, /**< Received frame CRC mismatches with expected. */
} ui_blackch_status_t;

/**
 * UI Black channel communication structure.
 */
typedef struct
{
    ui_blackch_status_t            status;                 /**< Communication status. */
    ui_blackch_rcvd_payload_cbk_t  pf_rcvd_payload_cbk;    /**< Pointer to function to consume received payload. */
} ui_blackch_t;


////////////////////////////////////////////////////////////////////////////////
// Private macros
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// Function prototypes
////////////////////////////////////////////////////////////////////////////////
static inline uint16_t ui_blackch_calc_frame_crc16(const ui_blackch_frame_t frame);
static ui_blackch_status_t ui_blackch_chk_rcvd_frame(const ui_blackch_frame_t rx_frame);


////////////////////////////////////////////////////////////////////////////////
// Variables
////////////////////////////////////////////////////////////////////////////////
/**
 * UI Black channel communication instance.
 */
static ui_blackch_t g_ui_blackch =
{
    .status = eUI_BLACKCH_OK,
    .pf_rcvd_payload_cbk = NULL,
};


////////////////////////////////////////////////////////////////////////////////
// Private Functions
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/**
*   Calculate CRC of the input frame.
*
* @param[in]    p_frame   pointer to frame data to be used for CRC calculation
* @return       crc         constructed frame ready to be transmitted
*/
////////////////////////////////////////////////////////////////////////////////
static uint16_t ui_blackch_calc_frame_crc16(const ui_blackch_frame_t frame)
{
    return ui_crc_16_arc_calculate( (uint8_t*)(&frame), (uint16_t)(sizeof(ui_blackch_frame_t) - sizeof(uint16_t)) );
}

////////////////////////////////////////////////////////////////////////////////
/**
* Check received frame validity and correctness .
*
* @param[in]    rx_frame    Frame.
* @return       Status flags.
*/
////////////////////////////////////////////////////////////////////////////////
static ui_blackch_status_t ui_blackch_chk_rcvd_frame(const ui_blackch_frame_t rx_frame)
{
    if (rx_frame.crc16 != ui_blackch_calc_frame_crc16(rx_frame))
    {
        g_ui_blackch.status |= eUI_BLACKCH_MISMATCH_CRC;
    }
    else
    {
        g_ui_blackch.status &= ~eUI_BLACKCH_MISMATCH_CRC;
    }

    return g_ui_blackch.status;
}


////////////////////////////////////////////////////////////////////////////////
// Public Functions
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/**
* Initialize module used for black channel communication.
*
* @param[in]    pf_rcvd_payload_cbk     Pointer to function to consume received payload.
* @return       Status.
*/
////////////////////////////////////////////////////////////////////////////////
void ui_blackch_init(ui_blackch_rcvd_payload_cbk_t pf_rcvd_payload_cbk)
{
    g_ui_blackch.pf_rcvd_payload_cbk = pf_rcvd_payload_cbk;
}

////////////////////////////////////////////////////////////////////////////////
/**
*   Construct frame from given payload.
*
* @param[in]    p_payload   pointer to payload to be put into frame
* @return       tx_frame    constructed frame ready to be transmitted
*/
////////////////////////////////////////////////////////////////////////////////
ui_blackch_frame_t ui_blackch_cstruct_frame(uint8_t cnt)
{
    ui_blackch_frame_t tx_frame;

    tx_frame.counter     = cnt;
    tx_frame.key_state   = 1;
    tx_frame.crc16       = ui_blackch_calc_frame_crc16( tx_frame );

    return tx_frame;
}

////////////////////////////////////////////////////////////////////////////////
/**
* Consume received frame under condition that its valid and correct and reset
* communication timeout.
*
* @param[in]    rx_frame    Received frame.
* @return       None.
*/
////////////////////////////////////////////////////////////////////////////////
void ui_blackch_rcv_frame(const ui_blackch_frame_t rx_frame)
{
    if (ui_blackch_chk_rcvd_frame(rx_frame) == eUI_BLACKCH_OK)
    {
        g_ui_blackch.pf_rcvd_payload_cbk(rx_frame.key_state);
    }
}

////////////////////////////////////////////////////////////////////////////////
/**
* @} <!-- END GROUP -->
*/
////////////////////////////////////////////////////////////////////////////////
