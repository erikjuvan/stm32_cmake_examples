////////////////////////////////////////////////////////////////////////////////
// COPYRIGHT (c) 2020
// EMTAS, EMSISO
// All rights reserved.
////////////////////////////////////////////////////////////////////////////////
/**
*@file   ico_queue.h
*@brief  contains defines for internal queue handling
*@author Zdenko Mezgec
*@author EMTAS
*@date   03.12.2020
*/
////////////////////////////////////////////////////////////////////////////////
/**
*@addtogroup CANOPEN
* @{ <!-- BEGIN GROUP -->
*/
////////////////////////////////////////////////////////////////////////////////
#ifndef ICO_QUEUE_H
#define ICO_QUEUE_H 1

////////////////////////////////////////////////////////////////////////////////
// Includes
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Definitions
////////////////////////////////////////////////////////////////////////////////

typedef struct {
	CO_CAN_MSG_T	msg;		/* can message */
	CO_SERVICE_T 	service;	/* canopen service */
	UNSIGNED16		spec;		/* service specification */
} CO_REC_DATA_T;

typedef struct {
	UNSIGNED8	data[CO_CAN_MAX_DATA_LEN];	/* data */
} CO_TRANS_DATA_T;

////////////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////////////
BOOL_T	icoQueueGetReceiveMessage(CO_REC_DATA_T	*pRecData);
RET_T	icoTransmitMessage(COB_REFERENZ_T cobRef,CO_CONST CO_TRANS_DATA_T *pData, UNSIGNED8 flags);
void	icoQueueHandler(void);
void	icoQueueDisable(BOOL_T on);
void	icoQueueDeleteInhibit(COB_REFERENZ_T cobRef);
RET_T   icoTransmitMessageDirectly(UNSIGNED32 u32_canid,UNSIGNED8 u8_message_len,UNSIGNED8 *pData); // pointer to transmit data

#endif /* ICO_QUEUE_H */
////////////////////////////////////////////////////////////////////////////////
/**
* @} <!-- END GROUP -->
*/
////////////////////////////////////////////////////////////////////////////////

